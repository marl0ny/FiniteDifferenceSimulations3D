let shaders = {};
shaders[`./shaders/add-forces.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float dt;\nuniform sampler2D forceTex;\nuniform sampler2D fluidVelocityTex;\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\n\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec4 forces = texture2D(forceTex, UV);\n    vec4 velocity = texture2D(fluidVelocityTex, UV);\n    fragColor = vec4(dt*forces.xyz + velocity.xyz, 0.0);\n    // float width3D = float(texelDimensions3D[0]);\n    // float height3D = float(texelDimensions3D[1]);\n    // float length3D = float(texelDimensions3D[2]);\n    // vec3 uvw = to3DTextureCoordinates(UV);\n    // float u = uvw[0], v = uvw[1], w = uvw[2];\n    // if (uvw[0] > 1.0/width3D && uvw[0] < 1.0 - 1.0/width3D &&\n    //     uvw[1] > 1.0/height3D && uvw[1] < 1.0 - 1.0/height3D &&\n    //     uvw[2] > 1.0/length3D && uvw[2] < 1.0 - 1.0/length3D) {\n    //     fragColor = vec4(dt*forces.xyz + velocity.xyz, velocity.w);\n    // } else {\n    //     fragColor = vec4(0.0);\n    // }\n}`;
shaders[`./shaders/advection-higher-or.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float dt;\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\n\nuniform sampler2D forwardTex;\nuniform sampler2D reverseTex;\nuniform sampler2D initialTex;\n\nuniform sampler2D velocityTex;\n\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvec4 clamp8(vec4 val,\n            vec4 c000, vec4 c100, vec4 c010, vec4 c110,\n            vec4 c001, vec4 c101, vec4 c011, vec4 c111) {\n    vec4 maxC = max(c000, max(c100, max(c010, max(c110, \n        max(c001, max(c101, max(c011, c111)))))));\n    vec4 minC = min(c000, min(c100, min(c010, min(c110, \n        min(c001, min(c101, min(c011, c111)))))));\n    return clamp(val, minC, maxC);\n}\n\nvec4 getSurroundingTexelValue(vec3 r, bvec3 offset) {\n    float w = float(texelDimensions3D[0]);\n    float h = float(texelDimensions3D[1]);\n    float d = float(texelDimensions3D[2]);\n    vec3 rOffset = vec3(\n        (((offset[0])? ceil(r.x*w - 0.5): floor(r.x*w - 0.5)) + 0.5)/w,\n        (((offset[1])? ceil(r.y*h - 0.5): floor(r.y*h - 0.5)) + 0.5)/h,\n        (((offset[2])? ceil(r.z*d - 0.5): floor(r.z*d - 0.5)) + 0.5)/d\n    );\n    return texture2D(initialTex, to2DTextureCoordinates(rOffset));\n}\n\nvec4 limiter(vec4 v) {\n    vec3 velocity = texture2D(velocityTex, UV).xyz;\n    vec3 uvw = to3DTextureCoordinates(UV);\n    vec3 r = uvw - (velocity/dimensions3D)*dt;\n    // if (r.x < 0.0 || r.x > 1.0 || r.y < 0.0 || r.y > 1.0) {\n    //     fragColor = vec4(0.0);\n    //     return;\n    // }\n    vec4 v000 = getSurroundingTexelValue(r, bvec3(0, 0, 0));\n    vec4 v100 = getSurroundingTexelValue(r, bvec3(1, 0, 0));\n    vec4 v010 = getSurroundingTexelValue(r, bvec3(0, 1, 0));\n    vec4 v110 = getSurroundingTexelValue(r, bvec3(1, 1, 0));\n    vec4 v001 = getSurroundingTexelValue(r, bvec3(0, 0, 1));\n    vec4 v101 = getSurroundingTexelValue(r, bvec3(1, 0, 1));\n    vec4 v011 = getSurroundingTexelValue(r, bvec3(0, 1, 1));\n    vec4 v111 = getSurroundingTexelValue(r, bvec3(1, 1, 1));\n    return clamp8(v, v000, v100, v010, v110, v001, v101, v011, v111);\n}\n \nvoid main() {\n    vec4 initial = texture2D(initialTex, UV);\n    vec4 forward = texture2D(forwardTex, UV);\n    vec4 reverse = texture2D(reverseTex, UV);\n    fragColor = limiter(forward + (initial - reverse)/2.0);\n}\n\n`;
shaders[`./shaders/advection.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\n\nuniform float dt;\nuniform sampler2D velocityTex;\nuniform sampler2D materialTex;\n\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n/* Bilinear interpolation */\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(texelDimensions3D[0]);\n    float height3D = float(texelDimensions3D[1]);\n    float length3D = float(texelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, ((dz == 0.0)? 0.0: (r.z - z0)/dz));\n}\n\nvoid main() {\n    vec3 velocity = texture2D(velocityTex, UV).xyz;\n    vec3 uvw = to3DTextureCoordinates(UV);\n    vec3 r = uvw - (velocity/dimensions3D)*dt;\n    fragColor = sample2DTextureAs3D(materialTex, r);\n    // if (r.x < 0.0 || r.x > 1.0 || r.y < 0.0 || r.y > 1.0)\n    //     fragColor = vec4(0.0);\n}`;
shaders[`./shaders/density-view.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float colorBrightness;\nuniform float alphaBrightness;\n\nvoid main() {\n    vec4 val = texture2D(tex, UV);\n    fragColor = vec4(val.rgb*colorBrightness, length(val.rgb)*alphaBrightness);\n}`;
shaders[`./shaders/diffusion-iter.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\nuniform float diffusionCoeff;\nuniform sampler2D toSolveTex;\nuniform sampler2D lastIterTex;\nuniform float dt;\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 du = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dv = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec3 dw = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    float dx = dimensions3D[0]/float(texelDimensions3D[0]);\n    float dy = dimensions3D[1]/float(texelDimensions3D[1]);\n    float dz = dimensions3D[2]/float(texelDimensions3D[2]);\n    vec3 duvw = vec3(du[0], dv[1], dw[2]);\n    vec3 dxyz = vec3(dx, dy, dz);\n    vec3 uvw = to3DTextureCoordinates(UV);\n    vec4 toSolveVal = texture2D(toSolveTex, UV);\n    vec4 vL, vR, vU, vD, vF, vB;\n    vL = texture2D(lastIterTex, to2DTextureCoordinates(uvw - du));\n    vR = texture2D(lastIterTex, to2DTextureCoordinates(uvw + du));\n    vU = texture2D(lastIterTex, to2DTextureCoordinates(uvw + dv));\n    vD = texture2D(lastIterTex, to2DTextureCoordinates(uvw - dv));\n    vF = texture2D(lastIterTex, to2DTextureCoordinates(uvw + dw));\n    vB = texture2D(lastIterTex, to2DTextureCoordinates(uvw - dw));\n    vec4 num = toSolveVal + dt*diffusionCoeff*(\n        (vL + vR)/(dx*dx) + (vU + vD)/(dy*dy) + (vF + vB)/(dz*dz));\n    float den = 1.0 \n        + 2.0*dt*diffusionCoeff*(1.0/(dx*dx) + 1.0/(dy*dy) + 1.0/(dz*dz));\n    fragColor = num/den;\n\n}`;
shaders[`./shaders/divergence.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\nuniform sampler2D tex;\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 du = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dv = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec3 dw = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    float dx = dimensions3D[0]/float(texelDimensions3D[0]);\n    float dy = dimensions3D[1]/float(texelDimensions3D[1]);\n    float dz = dimensions3D[2]/float(texelDimensions3D[2]);\n    vec3 uvw = to3DTextureCoordinates(UV);\n    // vec3 vC = texture2D(tex, UV).xyz;\n    vec3 vL = texture2D(tex, to2DTextureCoordinates(uvw - du)).xyz;\n    vec3 vR = texture2D(tex, to2DTextureCoordinates(uvw + du)).xyz;\n    vec3 vU = texture2D(tex, to2DTextureCoordinates(uvw + dv)).xyz;\n    vec3 vD = texture2D(tex, to2DTextureCoordinates(uvw - dv)).xyz;\n    vec3 vF = texture2D(tex, to2DTextureCoordinates(uvw + dw)).xyz;\n    vec3 vB = texture2D(tex, to2DTextureCoordinates(uvw - dw)).xyz;\n    fragColor = 0.5*vec4((vR - vL).x/dx + (vU - vD).y/dy + (vF - vB).z/dz);\n}`;
shaders[`./shaders/gradient/gradient3d.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nuniform int orderOfAccuracy;\n\n#define USE_TEXTURE_WRAPPING 0\n#define DIRICHLET 1\n#define DIRICHLET_MASK 2\nuniform int boundaryType;\n\nuniform sampler2D boundaryMaskTex;\n\nuniform int staggeredMode;\n\nuniform int index;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nuniform vec3 dr; // Spartial step sizes\nuniform vec3 dimensions3D; // Dimensions of simulation\n\n#define X_ORIENTATION 0\n#define Y_ORIENTATION 1\n#define Z_ORIENTATION 2\n\n/* Table of finite difference stencils:\n\n - Fornberg, B. (1988).\n Generation of Finite Difference Formulas on Arbitrarily Spaced Grids.\n Mathematics of Computation, 51(184), 699-706.\n https://doi.org/10.1090/S0025-5718-1988-0935077-0\n\n*/\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n/* Get the boundary value, given the 2D texture coordinate\nuv and its 3D equivalent counterpart uvw. */\nvec4 boundaryValue(vec2 uv, vec3 uvw) {\n    if (boundaryType == USE_TEXTURE_WRAPPING)\n        return vec4(1.0);\n    else if (boundaryType == DIRICHLET)\n        return  (\n            uvw[0] < dr[0]/dimensions3D[0] ||\n            uvw[1] < dr[1]/dimensions3D[1] ||\n            uvw[2] < dr[2]/dimensions3D[2] ||\n            uvw[0] > (1.0 - dr[0]/dimensions3D[0]) ||\n            uvw[1] > (1.0 - dr[1]/dimensions3D[1]) ||\n            uvw[2] > (1.0 - dr[2]/dimensions3D[2]))? vec4(0.0): vec4(1.0);\n    else if (boundaryType == DIRICHLET_MASK)\n        return texture2D(boundaryMaskTex, uv);\n}\n\n/* Sample the texture at an integer number of texel units (i, j, and k)\naway from the input 3D coordinate variable centre. */\nvec3 offsetTexelCoordinate3D(vec3 centre, int i, int j, int k) {\n    return centre + vec3(float(i)*dr[0]/dimensions3D[0],\n                         float(j)*dr[1]/dimensions3D[1],\n                         float(k)*dr[2]/dimensions3D[2]);\n}\n\n/* Sample the texture tex with its boundary value at an integer number of\ntexel units away from that position given in the varying/in UV variable. \nThe integer i denotes the  offset along the 0th direction, \nj along the 1st, and k along the 2nd. */\nvec4 valueAt(sampler2D tex, int i, int j, int k) {\n    vec3 uvw = to3DTextureCoordinates(UV).xyz;\n    vec3 uvwOffset = offsetTexelCoordinate3D(uvw, i, j, k);\n    vec2 uvOffset = to2DTextureCoordinates(uvwOffset);\n    vec4 b = boundaryValue(uvOffset, uvwOffset);\n    return b*texture2D(tex, uvOffset);\n}\n\nvec4 valueAt(sampler2D tex, int orientation, int i) {\n    if (orientation == X_ORIENTATION)\n        return valueAt(tex, i, 0, 0);\n    else if (orientation == Y_ORIENTATION)\n        return valueAt(tex, 0, i, 0);\n    else\n        return valueAt(tex, 0, 0, i);\n}\n\nvec4 centredDiff(sampler2D tex, int i) {\n    vec4 b = boundaryValue(UV, to3DTextureCoordinates(UV));\n    if (staggeredMode >= 1) {\n        return b*(valueAt(tex, i, 1)\n                  - valueAt(tex, i, 0))/dr[i];\n    } else if (staggeredMode == 0) {\n        if (orderOfAccuracy >= 4)\n            return b*((1.0/12.0)*valueAt(tex, i, -2) \n                    - (2.0/3.0)*valueAt(tex, i, -1)\n                    + (2.0/3.0)*valueAt(tex, i, 1)\n                    - (1.0/12.0)*valueAt(tex, i, 2)\n                   )/dr[i];\n        else\n            return 0.5*b*(valueAt(tex, i, 1)\n                          - valueAt(tex, i, -1))/dr[i];\n    } else if (staggeredMode <= -1) {\n        return b*(valueAt(tex, i, 0)\n                  - valueAt(tex, i, -1))/dr[i];\n    }\n}\n\n\n/* vec4 centredXDiff(sampler2D tex) {\n    // The destination texture is staggered foward relative to the source\n    // texture\n    if (staggeredMode >= 1) {\n    } else if (staggeredMode == 0) {\n        if (orderOfAccuracy >= 4)\n            return (  (1.0/12.0)*valueAt(tex, -2, 0, 0)\n                    - (2.0/3.0)*valueAt(tex, -1, 0, 0)\n                    + (2.0/3.0)*valueAt(tex,  1, 0, 0)\n                    - (1.0/12.0)*valueAt(tex,  2, 0, 0)\n                )/dr.x;\n        else\n            return 0.5*(valueAt(tex, 1, 0, 0) - valueAt(tex, -1, 0, 0))/dr.x;\n    } else if (staggeredMode <= -1) {\n\n    }\n}\n\nvec4 centredYDiff(sampler2D tex) {\n    if (orderOfAccuracy >= 4)\n        return (  (1.0/12.0)*valueAt(tex, 0, -2, 0)\n                - (2.0/3.0)*valueAt(tex, 0, -1, 0)\n                + (2.0/3.0)*valueAt(tex, 0,  1, 0)\n                - (1.0/12.0)*valueAt(tex, 0,  2, 0)\n               )/dr.y;\n    else\n        return 0.5*(valueAt(tex, 0, 1, 0) - valueAt(tex, 0, -1, 0))/dr.y;\n}\n\nvec4 centredZDiff(sampler2D tex) {\n    if (orderOfAccuracy >= 4)\n        return (  (1.0/12.0)*valueAt(tex, 0, 0, -2)\n                - (2.0/3.0)*valueAt(tex, 0, 0, -1)\n                + (2.0/3.0)*valueAt(tex, 0, 0,  1)\n                - (1.0/12.0)*valueAt(tex, 0, 0,  2)\n               )/dr.z;\n    else\n        return 0.5*(valueAt(tex, 0, 0, 1) - valueAt(tex, 0, 0, -1))/dr.z;\n}*/\n\nvoid main() {\n    vec4 dTexdx = centredDiff(tex, X_ORIENTATION);\n    vec4 dTexdy = centredDiff(tex, Y_ORIENTATION);\n    vec4 dTexdz = centredDiff(tex, Z_ORIENTATION);\n    fragColor = vec4(dTexdx[index], dTexdy[index], dTexdz[index], 1.0); \n}\n`;
shaders[`./shaders/pressure-iter.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\nuniform sampler2D toSolveTex;\nuniform sampler2D lastIterTex;\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvec4 offdiagLaplacian2ndOrder(sampler2D tex) {\n    vec4 pL, pR, pU, pD, pF, pB;\n    vec3 du = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dv = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec3 dw = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    float dx = dimensions3D[0]/float(texelDimensions3D[0]);\n    float dy = dimensions3D[1]/float(texelDimensions3D[1]);\n    float dz = dimensions3D[2]/float(texelDimensions3D[2]);\n    vec3 uvw = to3DTextureCoordinates(UV);\n    pR = texture2D(tex, to2DTextureCoordinates(uvw + du));\n    pL = texture2D(tex, to2DTextureCoordinates(uvw - du));\n    pU = texture2D(tex, to2DTextureCoordinates(uvw + dv));\n    pD = texture2D(tex, to2DTextureCoordinates(uvw - dv));\n    pF = texture2D(tex, to2DTextureCoordinates(uvw + dw));\n    pB = texture2D(tex, to2DTextureCoordinates(uvw - dw));\n    return (pL + pR)/(dx*dx) + (pU + pD)/(dy*dy) + (pF + pB)/(dz*dz);\n}\n\n\nvoid main() {\n    float dx = dimensions3D[0]/float(texelDimensions3D[0]);\n    float dy = dimensions3D[1]/float(texelDimensions3D[1]);\n    float dz = dimensions3D[2]/float(texelDimensions3D[2]);\n    vec4 toSolveVal = texture2D(toSolveTex, UV);\n    float diag = -2.0*(1.0/(dx*dx) + 1.0/(dy*dy) + 1.0/(dz*dz));\n    fragColor = (toSolveVal - offdiagLaplacian2ndOrder(lastIterTex))/diag;\n}       `;
shaders[`./shaders/sketch/add-to-density.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n\nuniform vec3 sigma;\nuniform vec3 location;\nuniform vec4 amplitude;\nuniform sampler2D tex;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nfloat gauss1D(float x, float x0, float sigma) {\n    return exp(-0.5*(x - x0)*(x - x0)/(sigma*sigma));\n}\n\nvoid main() {\n    vec3 xyz = to3DTextureCoordinates(UV);\n    float x = xyz[0], y = xyz[1], z = xyz[2];\n    float x0 = location[0], y0 = location[1], z0 = location[2];\n    float width3D = float(texelDimensions3D[0]);\n    float height3D = float(texelDimensions3D[1]);\n    float length3D = float(texelDimensions3D[2]);\n    float sx = sigma[0], sy = sigma[1], sz = sigma[2];\n    float g = gauss1D(x, x0, sx)*gauss1D(y, y0, sy)*gauss1D(z, z0, sz);\n    fragColor = vec4(amplitude.xyz*g + texture2D(tex, UV).xyz, 0.0);\n    // if (x > 1.0/width3D && x < 1.0 - 1.0/width3D &&\n    //     y > 1.0/height3D && y < 1.0 - 1.0/height3D &&\n    //     z > 1.0/length3D && z < 1.0 - 1.0/length3D) {\n    //     fragColor = amplitude*g + texture2D(tex, UV);\n    // } else {\n    //     fragColor = vec4(0.0);\n    // }\n}`;
shaders[`./shaders/sketch/init-dist.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define PI 3.141592653589793\n\nuniform vec3 sigma;\nuniform vec3 location;\nuniform vec4 amplitude;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nfloat gauss1D(float x, float x0, float sigma) {\n    return exp(-0.5*(x - x0)*(x - x0)/(sigma*sigma));\n}\n\nvoid main() {\n    vec3 xyz = to3DTextureCoordinates(UV);\n    float x = xyz[0], y = xyz[1], z = xyz[2];\n    float x0 = location[0], y0 = location[1], z0 = location[2];\n    float width3D = float(texelDimensions3D[0]);\n    float height3D = float(texelDimensions3D[1]);\n    float length3D = float(texelDimensions3D[2]);\n    float sx = sigma[0], sy = sigma[1], sz = sigma[2];\n    float g = gauss1D(x, x0, sx)*gauss1D(y, y0, sy)*gauss1D(z, z0, sz);\n    fragColor = amplitude*g;\n    // if (x > 1.0/width3D && x < 1.0 - 1.0/width3D &&\n    //     y > 1.0/height3D && y < 1.0 - 1.0/height3D &&\n    //     z > 1.0/length3D && z < 1.0 - 1.0/length3D) {\n    //     fragColor = amplitude*g;\n    // } else {\n    //     fragColor = vec4(0.0);\n    // }\n}`;
shaders[`./shaders/slices/planar-slice.vert`] = `#if __VERSION__ <= 120\nattribute vec3 position;\nvarying vec2 UV;\n#else\nin vec3 position;\nout vec2 UV;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#define quaternion vec4\n\nuniform vec3 offset;\nuniform float scale;\nuniform quaternion rotation;\nuniform ivec2 screenDimensions;\n    \nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*4.0/(x[2] + 4.0);\n    y[1] = float(screenDimensions[0])/float(screenDimensions[1])\n            *x[1]*4.0/(x[2] + 4.0);\n    y[2] = x[2]/4.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvoid main() {\n    UV = position.xy/2.0 + vec2(0.5, 0.5);\n    gl_Position = rotate(quaternion(scale*(position + offset), 1.0),\n                         rotation);\n}\n\n`;
shaders[`./shaders/slices/quartered-square-outline.vert`] = `#if __VERSION__ <= 120\nattribute vec3 position;\nvarying vec2 UV; //Not actually used!\n#else\nin vec3 position;\nout vec2 UV;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#define quaternion vec4\n\nuniform vec3 cursorPosition;\nuniform vec3 offset;\nuniform float scale;\nuniform quaternion rotation;\nuniform ivec2 screenDimensions;\n\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*4.0/(x[2] + 4.0);\n    y[1] = float(screenDimensions[0])/float(screenDimensions[1])\n            *x[1]*4.0/(x[2] + 4.0);\n    y[2] = x[2]/4.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvoid main() {\n    vec3 position2 = position;\n    // Make the center vertex have the same position\n    // as the cursor.\n    if (abs(position.x) < 1e-30 && abs(position.y) < 1e-30) {\n        position2 = cursorPosition;\n    } else if (position.x == 0.0) {\n        // Adjust the other vertices of the "cross" as well.\n        position2.x = cursorPosition.x;\n    } else if (position.y == 0.0) {\n        position2.y = cursorPosition.y;\n    }\n    UV = position2.xy/2.0 + vec2(0.5, 0.5);\n    gl_Position = rotate(quaternion(scale*(position2 + offset), 1.0),\n                         rotation);\n}\n`;
shaders[`./shaders/subtract-gradp.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\nuniform sampler2D fluidVelocityTex;\nuniform sampler2D pressureTex;\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 du = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dv = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec3 dw = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    float dx = dimensions3D[0]/float(texelDimensions3D[0]);\n    float dy = dimensions3D[1]/float(texelDimensions3D[1]);\n    float dz = dimensions3D[2]/float(texelDimensions3D[2]);\n    float pL, pR, pU, pD, pF, pB;\n    vec3 uvw = to3DTextureCoordinates(UV);\n    pL = texture2D(pressureTex, to2DTextureCoordinates(uvw - du))[0];\n    pR = texture2D(pressureTex, to2DTextureCoordinates(uvw + du))[0];\n    pU = texture2D(pressureTex, to2DTextureCoordinates(uvw + dv))[0];\n    pD = texture2D(pressureTex, to2DTextureCoordinates(uvw - dv))[0];\n    pF = texture2D(pressureTex, to2DTextureCoordinates(uvw + dw))[0];\n    pB = texture2D(pressureTex, to2DTextureCoordinates(uvw - dw))[0];\n    vec3 gradP = 0.5*vec3(\n        (pR - pL)/dx, (pU - pD)/dy, (pF - pB)/dz);\n    vec4 v = texture2D(fluidVelocityTex, UV);\n    fragColor = vec4(v.xyz - gradP, 0.0);\n}\n`;
shaders[`./shaders/util/abs-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = vec4(length(texture2D(tex, UV).xy));\n}`;
shaders[`./shaders/util/abs2-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length squared.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nvoid main() {\n    vec2 r = texture2D(tex, UV).xy;\n    fragColor = vec4(r.x*r.x + r.y*r.y);\n}\n\n\n`;
shaders[`./shaders/util/add2.frag`] = `/* Add two textures together */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n    fragColor = texture2D(tex1, UV) + texture2D(tex2, UV);\n}\n`;
shaders[`./shaders/util/blend2colors.frag`] = `/* Take the rgb values of two different textures and combine\nthe two together.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale1;\nuniform sampler2D tex1;\nuniform float scale2;\nuniform sampler2D tex2;\n\nvoid main() {\n    vec3 color1 = texture2D(tex1, UV).rgb;\n    vec3 color2 = texture2D(tex2, UV).rgb;\n    fragColor = vec4(scale1*abs(color1) + scale2*abs(color2), 1.0);\n}\n\n\n`;
shaders[`./shaders/util/copy-flip.frag`] = `/* Copy and flip the contents of a texture along the y-direction\n to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, vec2(UV.x, 1.0 - UV.y));\n}\n`;
shaders[`./shaders/util/copy.frag`] = `/* Copy the contents of a texture to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, UV);\n}\n`;
shaders[`./shaders/util/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\nReferences:\n\nWikipedia - Domain coloring\nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nWikipedia - Hue\nhttps://en.wikipedia.org/wiki/Hue\n\nhttps://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    vec3 color = brightness*length(z2)*argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/util/gray-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nvoid main() {\n    vec3 color = vec3(texture2D(tex, UV)[0] + offset);\n    fragColor \n        = vec4(max(min(brightness*color, maxBrightness), -maxBrightness),\n        1.0);\n}\n\n`;
shaders[`./shaders/util/mul.frag`] = `/* Do a component-wise multiplication of two textures. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n    fragColor = texture2D(tex1, UV)*texture2D(tex2, UV);\n}\n`;
shaders[`./shaders/util/sample3d.frag`] = `/* Sample and interpolate data points from the texture containing\nfrom a source texture that represents 3D data and write it to\nanother texture.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform ivec3 destinationTexelDimensions3D;\nuniform ivec2 destinationTexelDimensions2D;\nuniform ivec3 sourceTexelDimensions3D;\nuniform ivec2 sourceTexelDimensions2D;\n\n\nvec2 to2DSourceTextureCoordinates(vec3 uvw) {\n    int width2D = sourceTexelDimensions2D[0];\n    int height2D = sourceTexelDimensions2D[1];\n    int width3D = sourceTexelDimensions3D[0];\n    int height3D = sourceTexelDimensions3D[1];\n    int length3D = sourceTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DDestinationTextureCoordinates(vec2 uv) {\n    int width3D = destinationTexelDimensions3D[0];\n    int height3D = destinationTexelDimensions3D[1];\n    int length3D = destinationTexelDimensions3D[2];\n    int width2D = destinationTexelDimensions2D[0];\n    int height2D = destinationTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sourceTexelDimensions3D[0]);\n    float height3D = float(sourceTexelDimensions3D[1]);\n    float length3D = float(sourceTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSourceTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSourceTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSourceTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSourceTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSourceTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSourceTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSourceTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSourceTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    if (sourceTexelDimensions3D[0] < destinationTexelDimensions3D[0] &&\n        sourceTexelDimensions3D[1] < destinationTexelDimensions3D[1] &&\n        sourceTexelDimensions3D[2] < destinationTexelDimensions3D[2]) {\n        fragColor = sample2DTextureAs3D(\n            tex, to3DDestinationTextureCoordinates(UV));\n    } else {\n        fragColor = texture2D(\n            tex,\n            to2DSourceTextureCoordinates(\n                to3DDestinationTextureCoordinates(UV)));\n    }\n    // fragColor = vec4(1.0);\n}\n`;
shaders[`./shaders/util/scale-rgba.frag`] = `/* Scale a texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform vec4 scale;\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = scale*texture2D(tex, UV);\n}\n`;
shaders[`./shaders/util/scale.frag`] = `/* Scale a texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale;\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = scale*texture2D(tex, UV);\n}\n`;
shaders[`./shaders/util/slice-of-3d.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define XY_SLICE 0\n#define ZY_SLICE 1\n#define XZ_SLICE 2\nuniform int orientation;\nuniform int slice;\nuniform bool showAxis;\nuniform bool showOutline;\n\nuniform sampler2D tex;\nuniform ivec3 sourceTexelDimensions3D;\nuniform ivec2 sourceTexelDimensions2D;\n\n\nvec2 to2DSourceTextureCoordinates(vec3 uvw) {\n    int width2D = sourceTexelDimensions2D[0];\n    int height2D = sourceTexelDimensions2D[1];\n    int width3D = sourceTexelDimensions3D[0];\n    int height3D = sourceTexelDimensions3D[1];\n    int length3D = sourceTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sourceTexelDimensions3D[0]);\n    float height3D = float(sourceTexelDimensions3D[1]);\n    float length3D = float(sourceTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSourceTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSourceTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSourceTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSourceTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSourceTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSourceTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSourceTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSourceTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    vec3 uvw;\n    if (orientation == XY_SLICE) {\n        float z = (float(slice) + 0.5)/float(sourceTexelDimensions3D[2]);\n        uvw = vec3(UV[0], UV[1], z);\n    } else if (orientation == ZY_SLICE) { \n        float x = (float(slice) + 0.5)/float(sourceTexelDimensions3D[0]);\n        uvw = vec3(x, UV[1], UV[0]);\n    } else if (orientation == XZ_SLICE) {\n        float y = (float(slice) + 0.5)/float(sourceTexelDimensions3D[1]);\n        uvw = vec3(UV[0], y, UV[1]);\n    }\n    // fragColor = vec4(1.0);\n    // fragColor = vec4(5.0*uv[0], 0.0, 0.0, 1.0);\n    fragColor = vec4(sample2DTextureAs3D(tex, uvw).rgb, 1.0);\n    if (showAxis) {\n        if (abs(UV[0] - 0.5) < 1.0/float(sourceTexelDimensions2D[0]) ||\n            abs(UV[1] - 0.5) < 1.0/float(sourceTexelDimensions2D[1])) {\n            fragColor += vec4(1.0, 1.0, 1.0, 0.0);\n        }\n    }\n    if (showOutline) {\n        if (UV[0] < 1.0/float(sourceTexelDimensions2D[0]) ||\n            UV[0] > (1.0 - 1.0/float(sourceTexelDimensions2D[0])) ||\n            UV[1] < 1.0/float(sourceTexelDimensions2D[1]) ||\n            UV[1] > (1.0 - 1.0/float(sourceTexelDimensions2D[1]))) {\n            fragColor += vec4(1.0, 1.0, 1.0, 0.0);\n        }\n    }\n}`;
shaders[`./shaders/util/uniform-color.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform vec4 color;\n\nvoid main() {\n    fragColor = color;\n}`;
shaders[`./shaders/util/zero-boundaries-3d.frag`] = `/* For the 3D array data that's stored in the source texture,\n    set those values along the 3D array boundaries to zero. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\n\nuniform sampler2D tex;\n\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 uvw = to3DTextureCoordinates(UV);\n    vec3 dimensions3D = vec3(\n        float(texelDimensions3D[0]),\n        float(texelDimensions3D[1]),\n        float(texelDimensions3D[2])\n    );\n    vec4 texVal = texture2D(tex, UV);\n    if (uvw[0] < 1.0/dimensions3D[0] || \n        uvw[0] > (dimensions3D[0] - 1.0)/dimensions3D[0] ||\n        uvw[1] <  1.0/dimensions3D[1] || \n        uvw[1] > (dimensions3D[1] - 1.0)/dimensions3D[1] ||\n        uvw[2] <  1.0/dimensions3D[2] || \n        uvw[2] > (dimensions3D[2] - 1.0)/dimensions3D[2])\n        fragColor = vec4(0.0);\n    else\n        fragColor = texVal;\n}`;
shaders[`./shaders/util/zero.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nvoid main() {\n    fragColor = vec4(0.0);\n}\n`;
shaders[`./shaders/vol-render/cube-outline.vert`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nattribute vec3 position;\n#else\nin vec3 position;\n#endif\n\n#define quaternion vec4\n\nuniform float viewScale;\nuniform vec4 rotation;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return vec4(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvoid main() {\n    vec3 r = rotate(quaternion(position, 1.0), \n                    rotation).xyz*viewScale;\n    gl_Position = vec4(r, 1.0);\n}\n`;
shaders[`./shaders/vol-render/display.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform vec4 rotation;\nuniform sampler2D gradientTex;\nuniform sampler2D densityTex;\n\nuniform ivec3 fragmentTexelDimensions3D;\nuniform ivec2 fragmentTexelDimensions2D;\nuniform float alphaBrightness;\nuniform float colorBrightness;\n\n/* The variable UV from the previous shader contains \nthe 2D texture coordinate representation of the volume render.\nIt is 2D so that the gradient and density uniform textures are\nproperly sampled. These sampled gradient and density data points are used\ntogether to determine how the pixel should be displayed.\n\nThis corresponds to the shading step as given on the Wikipedia\npage for Volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = fragmentTexelDimensions2D[0];\n    int height2D = fragmentTexelDimensions2D[1];\n    int width3D = fragmentTexelDimensions3D[0];\n    int height3D = fragmentTexelDimensions3D[1];\n    int length3D = fragmentTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = fragmentTexelDimensions3D[0];\n    int height3D = fragmentTexelDimensions3D[1];\n    int length3D = fragmentTexelDimensions3D[2];\n    int width2D = fragmentTexelDimensions2D[0];\n    int height2D = fragmentTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n\n// void main() {\n//     vec3 r = to3DTextureCoordinates(UV);\n//     vec2 uv2 = to2DTextureCoordinates(r);\n//     fragColor = vec4(r.z, r.z, r.z, length(r));\n// }\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(fragmentTexelDimensions3D[0]);\n    float height3D = float(fragmentTexelDimensions3D[1]);\n    float length3D = float(fragmentTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    vec3 r = to3DTextureCoordinates(UV);\n    vec2 uv2 = to2DTextureCoordinates(r);\n    vec3 grad = texture2D(gradientTex, uv2).xyz;\n    vec4 density = texture2D(densityTex, uv2);\n    // vec3 grad = sample2DTextureAs3D(gradientTex, r).xyz;\n    // vec4 density = sample2DTextureAs3D(densityTex, r);\n    vec3 normal = rotate(quaternion(0.0, 0.0, 1.0, 1.0),\n                         conj(rotation)).xyz;\n    vec4 pix = density;\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    float dx = 1.0/float(texelDimensions3D[0]);\n    float dy = 1.0/float(texelDimensions3D[1]);\n    float dz = 1.0/float(texelDimensions3D[2]);\n    /* vec2 zF = to2DTextureCoordinates(vec3(r.x, r.y, r.z + dz));\n    vec2 zB = to2DTextureCoordinates(vec3(r.x, r.y, r.z - dz));\n    vec2 xF = to2DTextureCoordinates(vec3(r.x + dx, r.y, r.z));\n    vec2 xB = to2DTextureCoordinates(vec3(r.x - dx, r.y, r.z));\n    vec2 yF = to2DTextureCoordinates(vec3(r.x, r.y + dy, r.z));\n    vec2 yB = to2DTextureCoordinates(vec3(r.x, r.y - dy, r.z));\n    density = (texture2D(densityTex, zF)\n                 + texture2D(densityTex, zB)\n                 + texture2D(densityTex, xF)\n                 + texture2D(densityTex, xB)\n                + texture2D(densityTex, yF)\n                + texture2D(densityTex, yB)\n                 + density);*/\n    // pix.a = pix.b;\n    // lf (length(grad) < 0.0000001) discard;\n    if (pix.a < 0.05) discard;\n    if (dot(grad, grad) == 0.0) discard;\n    // fragColor = 4.0*pix;\n    float a = dot(normal, normalize(grad));\n    if (a <= 0.0) discard;\n    \n    // fragColor = vec4(1.0*normalize(density.rgb), a*a);\n    \n    // float densityLength = length(density.rgb);\n    // if (densityLength == 0.0) discard;\n    // fragColor = vec4(density.rgb/densityLength, a);\n    \n    fragColor = vec4(normalize(density.rgb)*colorBrightness, a*alphaBrightness);\n    \n    // fragColor = vec4(4.0*normalize(density.rgb), 0.1*a);\n    // fragColor = vec4(1.0);\n}`;
shaders[`./shaders/vol-render/display.vert`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nattribute vec2 uvIndex;\nvarying vec2 UV;\n#else\nin vec2 uvIndex;\nout vec2 UV;\n#endif\n\n#define quaternion vec4\n\nuniform vec4 debugRotation;\nuniform bool debugShow2DTexture;\nuniform float scale;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\n/* The attribute or input uvIndex contains the 2D coordinates represetation\nof the volume render frame, which is then converted to 3D coordinates\nand manipulated using the other uniforms.\nIt is also directly passed to the fragment shader as the varying or\nout variable UV, so that it can be used to sample the volume data which\nis store in the 2D texture format.\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec4 project(vec4 x) {\n    return vec4(x.x, x.y, 0.0, 1.0);\n    /* vec4 y;\n    y[0] = x[0]*5.0/(x[2] + 5.0);\n    y[1] = x[1]*5.0/(x[2] + 5.0);\n    y[2] = x[2];\n    y[3] = 1.0;\n    return y;*/\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    if (debugShow2DTexture) {\n        gl_Position = vec4(2.0*(uvIndex - vec2(0.5, 0.5)), 0.0, 1.0);\n        return;\n    }\n    UV = uvIndex.xy;\n    vec4 viewPos = vec4(to3DTextureCoordinates(UV), 1.0)\n                   - vec4(0.5, 0.5, 0.5, 0.0);\n    gl_Position = project(2.0*scale*rotate(viewPos, debugRotation));\n}\n`;
shaders[`./shaders/vol-render/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\nReferences:\n\nWikipedia - Domain coloring\nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nWikipedia - Hue\nhttps://en.wikipedia.org/wiki/Hue\n\nhttps://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\nuniform int brightnessMode;\nconst int ABS_VAL = 1;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    vec3 color = argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(brightness*length(z2)*color, brightness*length(z2));\n    float brightness2;\n    if (brightnessMode == ABS_VAL_SQUARED) {\n        brightness2 = brightness*length(z2)*length(z2);\n    } else if (brightnessMode == INV_ABS_VAL) {\n        brightness2 = brightness/(length(z2)) - 1.0;\n    } else {\n        brightness2 = brightness*length(z2);\n    }\n    fragColor = vec4(brightness2*color, brightness2);\n}\n`;
shaders[`./shaders/vol-render/gray-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nuniform int brightnessMode;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\nvoid main() {\n    float initVal = texture2D(tex, UV)[0];\n    float val;\n    if (brightnessMode == INV_ABS_VAL) {\n        val = 1.0/abs(initVal) + offset - 1.0;\n    } else if (brightnessMode == ABS_VAL_SQUARED) {\n        val = abs(initVal)*abs(initVal) + offset;\n    } else {\n        val = initVal + offset;\n    }\n    vec3 color = vec3(val);\n    fragColor \n        = vec4(max(min(brightness*color, maxBrightness), -maxBrightness),\n               max(min(brightness*val, maxBrightness), -maxBrightness));\n}\n\n`;
shaders[`./shaders/vol-render/sample-display.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform float viewScale;\n\nuniform vec4 rotation;\nuniform sampler2D gradientTex;\nuniform sampler2D densityTex;\n\nuniform ivec3 sampleTexelDimensions3D;\nuniform ivec2 sampleTexelDimensions2D;\nuniform ivec3 viewTexelDimensions3D;\nuniform ivec2 viewTexelDimensions2D;\n\n/* The variable UV from the previous shader contains \nthe 2D texture coordinate representation of the volume render.\nIt is 2D so that the gradient and density uniform textures are\nproperly sampled. These sampled gradient and density data points are used\ntogether to determine how the pixel should be displayed.\n\nThis corresponds to the shading step as given on the Wikipedia\npage for Volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\n/* Sample and interpolate data points from the texture containing the \ninitial raw 3D volumetric data to points on volume render frame.\nThis corresponds to the sampling step given in the Wikipedia page\nfor volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nvec2 to2DSampleTextureCoordinates(vec3 uvw) {\n    int width2D = sampleTexelDimensions2D[0];\n    int height2D = sampleTexelDimensions2D[1];\n    int width3D = sampleTexelDimensions3D[0];\n    int height3D = sampleTexelDimensions3D[1];\n    int length3D = sampleTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sampleTexelDimensions3D[0]);\n    float height3D = float(sampleTexelDimensions3D[1]);\n    float length3D = float(sampleTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSampleTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSampleTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSampleTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSampleTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSampleTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSampleTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSampleTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSampleTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = viewTexelDimensions3D[0];\n    int height3D = viewTexelDimensions3D[1];\n    int length3D = viewTexelDimensions3D[2];\n    int width2D = viewTexelDimensions2D[0];\n    int height2D = viewTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n\nvoid main() {\n    // float viewScaleAdj = max(viewScale, 2.0);\n    vec3 r = to3DTextureCoordinates(UV);\n    vec3 rSampler = rotate(quaternion(r - vec3(0.5), 1.0), \n                           conj(rotation)).xyz/viewScale + vec3(0.5);\n\n    // This check needs to be done to avoid a repeating effect\n    // caused by sampling beyond the initial boundary.\n    if (rSampler.x < 0.0 || rSampler.x >= 1.0 ||\n        rSampler.y < 0.0 || rSampler.y >= 1.0 ||\n        rSampler.z < 0.0 || rSampler.z >= 1.0) \n        discard;\n\n    vec3 grad = sample2DTextureAs3D(gradientTex, rSampler).xyz;\n    vec4 density = sample2DTextureAs3D(densityTex, rSampler);\n    if (density.a < 0.05)\n        discard;\n    if (dot(grad, grad) == 0.0)\n        discard;\n\n    vec3 normal = rotate(quaternion(0.0, 0.0, 1.0, 1.0),\n                         conj(rotation)).xyz;\n    float a = dot(normal, normalize(grad));\n    if (a <= 0.0)\n        discard;\n    fragColor = vec4(normalize(density.rgb), 0.1*a);\n}`;
shaders[`./shaders/vol-render/sample.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform sampler2D tex;\nuniform float viewScale;\nuniform vec4 rotation;\nuniform ivec3 volumeTexelDimensions3D;\nuniform ivec2 volumeTexelDimensions2D;\nuniform ivec3 dataTexelDimensions3D;\nuniform ivec2 dataTexelDimensions2D;\n\n/* Sample and interpolate data points from the texture containing the \ninitial raw 3D data to points on volume render frame.\nThis corresponds to the sampling step given in the Wikipedia page\nfor volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return vec4(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec2 to2DDataTextureCoordinates(vec3 uvw) {\n    int width2D = dataTexelDimensions2D[0];\n    int height2D = dataTexelDimensions2D[1];\n    int width3D = dataTexelDimensions3D[0];\n    int height3D = dataTexelDimensions3D[1];\n    int length3D = dataTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DVolumeTextureCoordinates(vec2 uv) {\n    int width3D = volumeTexelDimensions3D[0];\n    int height3D = volumeTexelDimensions3D[1];\n    int length3D = volumeTexelDimensions3D[2];\n    int width2D = volumeTexelDimensions2D[0];\n    int height2D = volumeTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(dataTexelDimensions3D[0]);\n    float height3D = float(dataTexelDimensions3D[1]);\n    float length3D = float(dataTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DDataTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DDataTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DDataTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DDataTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DDataTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DDataTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DDataTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DDataTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    vec4 viewPosition \n        = vec4(to3DVolumeTextureCoordinates(UV) - vec3(0.5), 1.0);\n    // float viewScaleAdj = max(viewScale, 2.0);\n    float viewScaleAdj = viewScale;\n    vec3 r = rotate(viewPosition, conj(rotation)).xyz/viewScaleAdj\n         + vec3(0.5);\n    // This check needs to be done to avoid a repeating effect\n    // caused by sampling beyond the initial boundary.\n    if (r.x < 0.0 || r.x >= 1.0 ||\n        r.y < 0.0 || r.y >= 1.0 ||\n        r.z < 0.0 || r.z >= 1.0) discard;\n    fragColor = sample2DTextureAs3D(tex, r);\n    // fragColor = vec4(1.0);\n}\n`;
shaders[`./shaders/vol-render/uniform-color-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\nuniform vec4 color;\n\nuniform int brightnessMode;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\nvoid main() {\n    float initVal = texture2D(tex, UV)[0];\n    float val;\n    if (brightnessMode == INV_ABS_VAL) {\n        val = brightness/initVal + brightness*offset - 1.0;\n    } else if (brightnessMode == ABS_VAL_SQUARED) {\n        val = brightness*(abs(initVal)*abs(initVal) + offset);\n    } else {\n        val = brightness*(initVal + offset);\n    }\n    fragColor \n        = vec4(max(min(val*color.rgb, maxBrightness),\n                 -maxBrightness),\n               max(min(val*color.a, maxBrightness), \n               -maxBrightness));\n}\n\n`;
const SHADERS = shaders;
export default SHADERS;
export const getShader = name => {console.log(`Getting ${name}.`); return SHADERS[name];}
